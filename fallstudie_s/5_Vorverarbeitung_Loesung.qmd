

# KW 42+43: Lösung Datenvorverarbeitung



```{r include=FALSE, echo=FALSE}
# Benoetigte Bibliotheken ####
library(tidyverse) # Data wrangling und piping
library(lubridate) # Arbeiten mit Datumsformaten
library(suncalc)   # berechne Tageszeiten abhaengig vom Sonnenstand
library(ggpubr)    # to arrange multiple plots in one graph
library(PerformanceAnalytics) # Plotte Korrelationsmatrix
library(MuMIn)     # Multi-Model Inference
library(AICcmodavg)# Modellaverageing
library(fitdistrplus)# Prueft die Verteilung in Daten
library(lme4)      # Multivariate Modelle
library(blmeco)    # Bayesian data analysis using linear models
library(sjPlot)    # Plotten von Modellergebnissen (tab_model)
library(lattice)   # einfaches plotten von Zusammenhängen zwischen Variablen


# definiere ein farbset zur wiedervewendung
mycolors <- c("orangered","gold", "mediumvioletred", "darkblue")

# Start und Ende ####
# Untersuchungszeitraum, ich waehle hier das Jahr 2019 bis und mit Sommer 2021
depo_start <- as.Date("2017-01-01")
depo_end <- as.Date("2022-7-31")

# Start und Ende Lockdown
lockdown <- read_delim("datasets/fallstudie_s/lockdown.csv")

lock_1_start <- as.Date("2020-03-16")
lock_1_end <- as.Date("2020-05-11")

lock_2_start <- as.Date("2020-12-22")
lock_2_end <- as.Date("2021-03-01")


# Ebenfalls muessen die erste und letzte Kalenderwoche der Untersuchungsfrist definiert werden
# Diese werden bei Wochenweisen Analysen ebenfalls ausgeklammert da sie i.d.R. unvollstaendig sind
KW_start <- isoweek(depo_start)
KW_end <- isoweek(depo_end)


# Erster und letzter Tag der Ferien
# je nach Untersuchungsdauer muessen hier weitere oder andere Ferienzeiten ergaenzt werden
# (https://www.schulferien.org/schweiz/ferien/2020/)

schulferien <- read_delim("datasets/fallstudie_s/ferien.csv", ",")



```

# Aufgabe 1: Zähldaten

```{r}
# lese die Daten ein 
# Je nach Bedarf muss der Speicherort sowie der Dateiname angepasst werden
depo <- read_delim("datasets/fallstudie_s/WPZ/211_sihlwaldstrasse_2017_2022.csv", ";")

# Hinweis zu den Daten:
# In hourly analysis format, the data at 11:00 am corresponds to the counts saved between 
# 11:00 am and 12:00 am.

# Anpassen der Datentypen und erstes Sichten
str(depo)

depo <- depo |>
  mutate(
    Datetime = as.POSIXct(DatumUhrzeit, format = "%d.%m.%Y %H:%M", tz = "CET"),
    Datum = as.Date(Datetime)
    ) #|> 
  # Schneide das df auf den gewuenschten Zeitraum zu
  # filter(Datetime >= depo_start, Datum <=  depo_end) # das Komma hat die gleiche Funktion wie ein &

# In dieser Auswertung werden nur Personen zu Fuss betrachtet!
# it select werden spalten ausgewaehlt oder eben fallengelassen
depo <- depo |> 
  dplyr::select(-c(Velo_IN, Velo_OUT, Zeit, DatumUhrzeit))

# Berechnen des Totals, da dieses in den Daten nicht vorhanden ist
depo <- depo|>
  mutate(Total = Fuss_IN + Fuss_OUT)

# Entferne die NA's in dem df.
depo <- na.omit(depo)
```

# Aufgabe 2: Meteodaten

```{r}
# Einlesen
meteo <- read_delim("datasets/fallstudie_s/WPZ/order_105742_data.txt", ";")

# Datentypen setzen
# Das Datum wird als Integer erkannt. Zuerst muss es in Text umgewaldelt werden aus dem dann
# das eigentliche Datum herausgelesen werden kann
meteo <- mutate(meteo, time = as.Date(as.character(time), "%Y%m%d"))

# Die eigentlichen Messwerte sind alle nummerisch
meteo <- meteo|>
  mutate(tre200jx = as.numeric(tre200jx))|>
  mutate(rre150j0 = as.numeric(rre150j0))|>
  mutate(sremaxdv = as.numeric(sremaxdv)) |> 
  filter(time >= depo_start, time <=  depo_end) # schneide dann auf Untersuchungsdauer

# Was ist eigentlich Niederschlag:
# https://www.meteoschweiz.admin.ch/home/wetter/wetterbegriffe/niederschlag.html

# Filtere Werte mit NA
meteo <- na.omit(meteo)
# Pruefe ob alles funktioniert hat
str(meteo)
sum(is.na(meteo)) # zeigt die Anzahl NA's im data.frame an
```

# Aufgabe 3: Datenvorverarbeitung (Mutationen)

```{r}
#.################################################################################################
# 2. VORBEREITUNG DER DATEN #####
#.################################################################################################

# 2.1 Convinience Variablen ####
# fuege dem Dataframe (df) die Wochentage hinzu
depo <- depo |> 
  mutate(Wochentag = wday(Datetime, week_start = 1)) |> 
  # Werktag oder Wochenende hinzufuegen
  mutate(Wochenende = ifelse(Wochentag %in% c(6,7), "Wochenende", "Werktag")) |>
  # Kalenderwoche hinzufuegen
  mutate(KW = isoweek(Datetime))|>
  # monat und Jahr
  mutate(Monat = month(Datetime)) |> 
  mutate(Jahr = year(Datetime))

#Lockdown 
# Hinweis: ich mache das nachgelagert, da ich die Erfahrung hatte, dass zu viele 
# Operationen in einem Schritt auch schon mal durcheinander erzeugen koennen.
# Hinweis II: Wir packen alle Phasen (normal, die beiden Lockdowns und Covid aber ohne Lockdown)
# in eine Spalte --> long ist schoener als wide
depo <- depo |>
  mutate(Phase = case_when(
    Datetime < lock_1_start ~ "Pre",
    Datetime >= lock_1_start & Datetime <= lock_1_end ~ "Lockdown_1",
    Datetime > lock_1_end & Datetime < lock_2_start ~ "Normal",
    Datetime >= lock_2_start & Datetime <= lock_2_end ~ "Lockdown_2",
    Datetime > lock_2_end ~ "Post"
  ))

# hat das gepklappt?!
unique(depo$Phase)

# aendere die Datentypen
depo <- depo |> 
  mutate(Wochenende = as.factor(Wochenende)) |> 
  mutate(KW = factor(KW)) |> 
  # mit factor() koennen die levels direkt einfach selbst definiert werden.
  # wichtig: speizfizieren, dass aus R base, ansonsten kommt es zu einem 
  # mix-up mit anderen packages
  mutate(Phase = factor(Phase))

str(depo)
  
# Fuer einige Auswertungen muss auf die Stunden als nummerischer Wert zurueckgegriffen werden
depo$Stunde <- hour(depo$Datetime)

# ersetze 0 Uhr mit 24 Uhr (damit wir besser rechnen können)
# depo$Stunde[depo$Stunde == 0] <- 24
unique(depo$Stunde)
typeof(depo$Stunde)

# Die Daten wurden kalibriert. Wir runden sie fuer unserer Analysen auf Ganzzahlen
depo$Total <- round(depo$Total, digits = 0)
depo$Fuss_IN <- round(depo$Fuss_IN, digits = 0)
depo$Fuss_OUT <- round(depo$Fuss_OUT, digits = 0)

# 2.2 Tageszeit hinzufuegen ####

# Einteilung Standort Zuerich
Latitude <- 47.38598
Longitude <- 8.50806


# Welche Zeitzone haben wir eigentlich?
# Switzerland uses Central European Time (CET) during the winter as standard time, 
# which is one hour ahead of Coordinated Universal Time (UTC+01:00), and 
# Central European Summer Time (CEST) during the summer as daylight saving time, 
# which is two hours ahead of Coordinated Universal Time (UTC+02:00).
# https://en.wikipedia.org/wiki/Time_in_Switzerland

# Was sind Astronomische Dämmerung und Golden Hour ueberhaupt?
# https://sunrisesunset.de/sonne/schweiz/zurich-kreis-1-city/
# https://www.rdocumentation.org/packages/suncalc/versions/0.5.0/topics/getSunlightTimes

# Wir arbeiten mit folgenden Variablen:
# "nightEnd" : night ends (morning astronomical twilight starts)
# "goldenHourEnd" : morning golden hour (soft light, best time for photography) ends
# "goldenHour" : evening golden hour starts
# "night" : night starts (dark enough for astronomical observations)

lumidata <-
  getSunlightTimes(
    date = seq.Date(depo_start, depo_end, by = 1),
    keep = c("nightEnd", "goldenHourEnd", "goldenHour", "night"),
    lat = Latitude,
    lon = Longitude,
    tz = "CET")  |>
    as_tibble()


```


```{r}
# jetzt haben wir alle noetigen Angaben zu Sonnenaufgang, Tageslaenge usw. 
# diese Angaben koennen wir nun mit unseren Zaehldaten verbinden:
depo <- depo |>
  left_join(lumidata, by = c(Datum = "date"))

# im naechsten Schritt weise ich den Stunden die Tageszeiten Morgen, Tag, Abend und Nacht zu.
# diese Zuweisung basiert auf der Einteilung gem. suncalc und eigener Definition.
depo <- depo|>
  mutate(Tageszeit = case_when(
    Datetime >= nightEnd & Datetime <= goldenHourEnd ~ "Morgen",
    Datetime > goldenHourEnd & Datetime < goldenHour ~ "Tag",
    Datetime >= goldenHour & Datetime <= night       ~ "Abend",
    .default = "Nacht"
  )) |>
  mutate(Tageszeit = factor(Tageszeit, levels = c("Morgen", "Tag", "Abend", "Nacht"),ordered = TRUE))

# # behalte die relevanten Var
depo <- depo |> dplyr::select(-nightEnd, -goldenHourEnd, -goldenHour, -night)

#Plotte zum pruefn ob das funktioniert hat
ggplot(depo, aes(y = Datetime, color = Tageszeit, x = Stunde))+
  geom_jitter()+
  scale_color_manual(values = mycolors)


```


# Aufgabe 4: Aggregierung der Stundendaten

```{r}
# 2.4 Aggregierung der Stundendaten zu ganzen Tagen ####
# Zur Berechnung von Kennwerten ist es hilfreich, wenn neben den Stundendaten auch auf Ganztagesdaten
# zurueckgegriffen werden kann
# hier werden also pro Nutzergruppe und Richtung die Stundenwerte pro Tag aufsummiert
depo_d <- depo |> 
  group_by(Datum, Wochentag, Wochenende, KW, Monat, Jahr, Phase) |> 
  summarise(Total = sum(Fuss_IN + Fuss_OUT), 
            Fuss_IN = sum(Fuss_IN),
            Fuss_OUT = sum(Fuss_OUT)) 
# Wenn man die Convinience Variablen als grouping variable einspeisst, dann werden sie in 
# das neue df uebernommen und muessen nicht nochmals hinzugefuegt werden
# pruefe das df
head(depo_d)

# nun gruppieren wir nicht nur nach Tag sondern auch noch nach Tageszeit
depo_daytime <- depo |> 
  group_by(Datum, Wochentag, Wochenende, KW, Monat, Jahr, Phase, Stunde) |> 
  summarise(Total = sum(Fuss_IN + Fuss_OUT), 
            Fuss_IN = sum(Fuss_IN),
            Fuss_OUT = sum(Fuss_OUT)) 


# Gruppiere die Werte nach Monat
depo_m <- depo |> 
  group_by(Jahr, Monat) |> 
  summarise(Total = sum(Total)) 

depo_m <- depo_m |> 
  mutate(Ym = paste(Jahr, Monat)) |> # und mache eine neue Spalte, in der Jahr und
  mutate(Ym = lubridate::ym(Ym)) # formatiere als Datum

# Gruppiere die Werte nach Monat und TAGESZEIT
depo_m_daytime <- depo |> 
  group_by(Jahr, Monat, Stunde) |> 
  summarise(Total = sum(Total)) 
# sortiere das df aufsteigend (nur das es sicher stimmt)

depo_m_daytime <- depo_m_daytime |> 
  mutate(Ym = paste(Jahr, Monat)) |> # und mache eine neue Spalte, in der Jahr und
  mutate(Ym = lubridate::ym(Ym)) # formatiere als Datum
```

