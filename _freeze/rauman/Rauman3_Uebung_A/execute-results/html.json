{
  "hash": "c7529317fb0c8564ce38cebb34c7b480",
  "result": {
    "markdown": "---\ndate: 2022-12-05\nlesson: RaumAn3\nthema: Morans I\nindex: 1\nexecute: \n  echo: true   # set to true to show musterlösung\n  output: true # set to true to show musterlösung\ncode-fold: true\ncode-summary: \"Musterlösung\"\nknitr:\n  opts_chunk: \n    collapse: true  \n---\n\n\n# Rauman 3: Übung\n\n\nHeute berechnen wir Morans $I$, also ein globales Mass für Autokorrelation, für die Abstimmungsresultate der Zweitwohnungsinitiative. Dieser Wert beschreibt, ob Kantone, die nahe beieinander liegen, ähnliche Abstimmungswerte haben. Hierfür verwenden wir den Datensatz [zweitwohnungsinitiative.gpkg](https://moodle.zhaw.ch/mod/resource/view.php?id=602283).\n\nDas Geopackage beinhaltet 3 Layers (siehe `st_layers(zweitwohnung_kanton)`). In jedem Layer sind die Abstimmungsresultate auf eine andere politische Ebene aggregiert. Wir started mit der Aggregationsstufe \"kanton\".\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\nlibrary(\"dplyr\")\nlibrary(\"ggplot2\")\nlibrary(\"sf\")\n\nzweitwohnung_kanton <- read_sf(\"datasets/rauman/zweitwohnungsinitiative.gpkg\", \"kanton\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\np <- ggplot(zweitwohnung_kanton) +\n  geom_sf(aes(fill = ja_in_percent), colour = \"white\",lwd = 0.2) +\n  scale_fill_gradientn(colours = RColorBrewer::brewer.pal(11, \"RdYlGn\"), limits = c(0,1))  +\n  theme(legend.position = \"bottom\")\n\np\n```\n\n::: {.cell-output-display}\n![Was für einen Autokorrelationswert würdest du erwarten? Eher 1 (hohe Autokorrelation, beieinanderliegende Kantone haben ähnliche Werte) oder eher -1 (beieinanderliegende Kantone haben sehr unterschiedliche Werte) oder eher 0 (gar keine Autokorrelation)](Rauman3_Uebung_A_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n\nFür die Berechnung von Morans $I$ benutzen wir kein externes Package, sondern erarbeiten uns alles selber, basierend auf der Formel von Moran's $I$: \n\n\n$$I = \\frac{n}{\\sum_{i=1}^n (y_i - \\bar{y})^2} \\times \\frac{\\sum_{i=1}^n \\sum_{j=1}^n w_{ij}(y_i - \\bar{y})(y_j - \\bar{y})}{\\sum_{i=1}^n \\sum_{j=1}^n w_{ij}}$$\n\n\n\nwobei:\n\n- $n$ der Anzahl räumlichen Objekte (hier: Kantone) in unserem Datensatz entspricht\n- $y$ der untersuchten Variabel entspricht (hier: Ja-Anteil in %)\n- $\\bar{y}$ dem Mittelwert der untersuchten Variabel entspricht\n- $w_{ij}$ der Gewichtsmatrix entspricht\n\n\nUm die Sache zu vereinfachen, verwenden wir folgende variablen in R:\n\n\n$$I =\\frac{\\text{zaehler1}}{\\text{nenner1}}\\times\\frac{\\text{zaehler2}}{\\text{nenner2}}$$\n\n\nwobei:\n\n\\begin{align}\n\n\\text{zaehler1} &= n \\\\\n\\text{nenner1} &= \\sum_{i=1}^n (y_i - \\bar{y})^2 \\\\\n\\text{zaehler2} &= \\sum_{i=1}^n \\sum_{j=1}^n w_{ij}(y_i - \\bar{y})(y_j - \\bar{y}) \\\\\n\\text{nenner2} &= \\sum_{i=1}^n \\sum_{j=1}^n w_{ij}\n\n\\end{align}\n\nDiese sieht sehr beeindruckend aus, aber wenn wir die Formel in ihre Einzelbestandteile aufteilen, sehen wir, dass diese in sich gar nicht so komplex sind. Dieses Vorgehen illustriert sehr schön ein generelles Data Science Prinzip. Divide and Conquer - Teile und Herrsche: Teile ein komplexes Problem in kleinere, beherrschbare Unterprobleme. \n\n## Aufgabe 1: Morans $I$ für Kantone\n\n### Berechnung von $n$ (`zaehler1`)\n\n\n$$I = \\frac{\\color{red}n}{\\sum_{i=1}^{\\color{orange}n} (y_i - \\bar{y})^2} \\times \\frac{\\sum_{i=1}^n \\sum_{j=1}^{\\color{orange}n}  w_{ij}(y_i - \\bar{y})(y_j - \\bar{y})}{\\sum_{i=1}^n \\sum_{j=1}^{\\color{orange}n}  w_{ij}}$$\n\n\nBeginnen wir mit der Variabel $n$, bzw. der Variabel `zaehler1` (rot in der obigen Formel). Dies ist lediglich die Anzahl Messwerte in unserem Datensatz, also die Anzahl Kantone. Wir merken uns `n` vor, da wir diese noch mehrmals in der Formel antreffen werden (orange).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn <- nrow(zweitwohnung_kanton)\nn\n## [1] 26\n\nzaehler1 <- n\n```\n:::\n\n\n### Abweichung vom Mittelwert (`nenner1`)\n\n\n$$I = \\frac{n}{\\color{red}\\sum_{i=1}^n (y_i - \\bar{y})^2} \\times \\frac{{\\color{orange}\\sum_{i=1}^n} \\sum_{j=1}^n w_{ij}{\\color{orange}(y_i - \\bar{y})(y_j - \\bar{y})}}{\\sum_{i=1}^n \\sum_{j=1}^n w_{ij}}$$\n\n\nDieses Summenfunktion bedeutet, das wir eine Schlaufe (einen Loop) durchführen sollen. Vom ersten Kanton ($\\sum_{\\color{red}i=1}^n$) bist zum letzten Kanton ($\\sum_{i=1}^{\\color{red}n}$) sollen wir: \n\n*Den Mittleren Ja-Stimmen-Anteil aller Kantone vom Ja-Stimmen-Anteil des jeweiligen Kantons abziehen und das Resultat quadrieren.*\n\nDafür erstellen wir als erstes die Variabel `y`, sowie ein Vektor der Länge 26 (Anzahl Kantone) um die Resultate zu speichern (hier: `result`)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- zweitwohnung_kanton$ja_in_percent\n\n# Wir erstellen ein Vector der länge 26 (1 pro Kanton) \n# um die Resultate zu speichern.\nresultat <- double(length = n)\n\n# jetzt können wir den For Loop ausführen\nfor (i in 1:n){\n  resultat[i] <- (y[i]-mean(y))^2\n}\n\nresultat\n##  [1] 0.0008726497 0.0029255763 0.0004834762 0.0121020552 0.0045148421\n##  [6] 0.0065361452 0.0057467371 0.0001244131 0.0021889669 0.0001613522\n## [11] 0.0044765772 0.0172266246 0.0052080053 0.0060126495 0.0041475008\n## [16] 0.0007085313 0.0005014960 0.0046799162 0.0001270748 0.0010402720\n## [21] 0.0012336230 0.0011046664 0.0536451330 0.0033645831 0.0043781582\n## [26] 0.0019028888\n```\n:::\n\n\nNach der Durchführung aller Iterationen, haben wir 26 Einzelwerte, die wir Summieren müssen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnenner1 <- sum(resultat)\n```\n:::\n\n\n:::{.callout-note collapse=\"true\"}\n## Für aufmerksame\n\nDa R per Default vektorisiert funktioniert, ist der obige For Loop streng genommen nicht nötig, wir verwenden ihn aber für didaktische Zwecke. Alternativ ginge die Berechnung von `nenner1` auch folgendermassen:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"false\"}\n# Von jedem Wert den Durchschnittswert abziehen:\ndy <- y - mean(y)\n\n# Diese Werte müssen wir quadrieren:\ndy_squared <- dy^2\n\n# Und danach die Summe bilden:\nnenner1 <- sum(dy_squared, na.rm = TRUE)\n```\n:::\n\n\n:::\n\n### Summe der Gewichte (`nenner2`)\n\n\n$$I = \\frac{n}{\\sum_{i=1}^n (y_i - \\bar{y})^2} \\times \\frac{\\sum_{i=1}^n \\sum_{j=1}^n w_{ij}(y_i - \\bar{y})(y_j - \\bar{y})}{\\color{red}\\sum_{i=1}^n \\sum_{j=1}^n w_{ij}}$$\n\n\nIm zweiten Term müssen wir jeweils zwei doppelte Summenzeichen auflösen. Der Nenner des zweiten Terms ist etwas einfacher zu verstehen, deshalb beginnen wir mit diesem.\n\n#### Räumliche Gewichtung $w_{ij}$\n\n\n$$I = \\frac{n}{\\sum_{i=1}^n (y_i - \\bar{y})^2} \\times \\frac{\\sum_{i=1}^n \\sum_{j=1}^n {\\color{orange}w_{ij}}(y_i - \\bar{y})(y_j - \\bar{y})}{\\sum_{i=1}^n \\sum_{j=1}^n {\\color{red}w_{ij}}}$$\n\n\n\n$w$ beschreibt die räumlichen Gewichte der Kantone (den \"Schalter\" aus der Vorlesung). $w_{ij}$ ist das Gewicht vom Kanton $i$ im Vergleich zum Kanton $j$. Sind Kantone $i$ und $j$ räumlich nah, gilt ein Gewicht von 1, sind sie weit entfernt, gilt ein Gewicht von 0. Dabei ist die Definition von \"räumlich nah\" nicht festgelegt. Denkbar wären zum Beispiel folgende Optionen:\n\n1. Die Kantone müssen sich berühren\n2. Die Kantone müssen innerhalb einer bestimmten Distanz zueinander liegen\n\nFür beide Optionen gibt es eine implementation im Package `sf`. `st_touches` prüft zwischen allen Kantonen, ob sie sich berühren. Mit der Option `sparse = TRUE` wird eine Kreuzmatrix mit 26 Zeilen und 26 Spalten erstellt, wo jeder Kanton mit jedem anderen verglichen wird. Berühren sie sich, steht in der entsprechenden Stelle der Wert `TRUE`, was in R gleichbedeutend ist wie 1. Berühren sie sich *nicht*, steht der Wert `FALSE`, was gleichbedeutend ist wie 0. Das gleiche gilt für die Funktion `st_is_within_distance()` wobei dort zusätzlich noch der Distanzparameter angegeben werden muss.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# st_touches berechnet eine Kreuzmatrix aller Objekte\nw <- st_touches(zweitwohnung_kanton, sparse = FALSE)\n\n# Schauen wir uns die ersten 5 Reihen und Zeilen an\nw[1:5, 1:5]\n##       [,1]  [,2]  [,3]  [,4]  [,5]\n## [1,] FALSE FALSE FALSE FALSE  TRUE\n## [2,] FALSE FALSE  TRUE  TRUE FALSE\n## [3,] FALSE  TRUE FALSE FALSE  TRUE\n## [4,] FALSE  TRUE FALSE FALSE  TRUE\n## [5,]  TRUE FALSE  TRUE  TRUE FALSE\n```\n:::\n\n\nIn der obigen Matrix ist ersichtlich, dass sich der erste Kanton (erste Zeile) den fünften Kanton (fünfte Spalte) berührt. Um zu überprüfen ob das stimmt, können wir die Namen dieser beiden Kantone aus der Spalte `KANTONSNAME` herauslesen und mit unseren Geografiekentnissen abgleichen:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nzweitwohnung_kanton$KANTONSNAME[c(1,5)]\n## [1] \"Zürich\" \"Schwyz\"\n```\n:::\n\n\nDer erste Kanton ist Zürich, der fünfte Schwyz, das scheint also Sinn zu stimmen. Challenge: Erstelle einen Plot mit allen Kantone, die den Kanton Zürich berühren. Tipp: Nutze dafür `w[1,]`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nberuehrt_1 <- w[1, ]\n\nggplot(zweitwohnung_kanton[beruehrt_1, ]) +\n  geom_sf(aes(fill = KANTONSNAME)) +\n  labs(title = \"Welche Kanton berühren den Kanton Zürich (st_touches)\")\n```\n\n::: {.cell-output-display}\n![](Rauman3_Uebung_A_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\n\n#### Doppelte Summenzeichen {#sec-doppeltes-summenzeichen}\n\n\n$$I = \\frac{n}{\\sum_{i=1}^n (y_i - \\bar{y})^2} \\times \\frac{{\\color{orange}\\sum_{i=1}^n \\sum_{j=1}^n} w_{ij}(y_i - \\bar{y})(y_j - \\bar{y})}{{\\color{red}\\sum_{i=1}^n \\sum_{j=1}^n} w_{ij}}$$\n\n\nNun können wir das doppelte Summenzeichen auflösen. Genau wie bei einem einfachen Summenzeichen handelt es sich hier um *For Loop*, diesmal aber um zwei ineinnader verschachtelte *For Loops*. Der äussere *For loop* ($\\sum_{i=1}^n$) iteriert von `1` bis `n` mit der Variabel `i`. Der innere *For loop* ($\\sum_{j=1}^n$) iteriert von `1` bis `n` mit der Variabel `j`. \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresultat_aussen <- integer(length = n)\nfor (i in 1:n){\n  resultat_innen <- integer(length = n)\n  for (j in 1:n){\n    resultat_innen[j] <- w[i, j]\n  }\n  resultat_aussen[i] <- sum(resultat_innen)\n}\nnenner2 <- sum(resultat_aussen)\n```\n:::\n\n\n\n\n\n### Berechnung des Kreuzprodukts (`zaehler2`)\n\n\n$$I = \\frac{n}{\\sum_{i=1}^n (y_i - \\bar{y})^2} \\times \\frac{\\color{red}\\sum_{i=1}^n \\sum_{j=1}^n w_{ij}(y_i - \\bar{y})(y_j - \\bar{y})}{\\sum_{i=1}^n \\sum_{j=1}^n w_{ij}}$$\n\n\nJetzt haben wir das fehlende Puzzelstück für die Berechnung von `zaehler2`. Challenge: Nutze die matrix `w` in dem verschachtelten For Loop aus @sec-doppeltes-summenzeichen\n\n\n::: {.cell}\n\n```{.r .cell-code}\n\nresultat_aussen <- double(length = n)\n\nfor (i in 1:n){\n  resultat_innen <- double(length = n)\n  for (j in 1:n){\n    resultat_innen[j] <- w[i,j] * (y[i]-mean(y))*(y[j]-mean(y))\n  }\n  resultat_aussen[i] <- sum(resultat_innen)\n}\n\nzaehler2 <- sum(resultat_aussen)\n```\n:::\n\n\n### Auflösung der Formel\n\nNun haben wir alle Bestandteile von Morans $I$ Berechnet und müssen diese nur noch Zusammenrechnen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nMI_kantone <- zaehler1/nenner1 * zaehler2/nenner2\n\nMI_kantone\n## [1] 0.3148631\n```\n:::\n\n\nDer Global Morans $I$ für die Abstimmungsdaten beträgt auf Kantonsebene also 0.31. Wie interpretiert ihr dieses Resultate? Was erwartet ihr für eine Resultat auf Gemeinde- oder Bezirksebene?\n\n## Aufgabe 2: Morans I für Bezirke berechnen\n\nNun könnt ihr Morans $I$ auf der Ebene der Bezirke und untersuchen, ob und wie sich Morans $I$ verändert. Importiert dazu den Layer `bezirk` aus dem Datensatz `zweitwohnungsinitiative.gpkg`. Visualisiert in einem ersten Schritt die Abstimmungsresultate. Tipp: wir verwenden das Package `cowplot` um zwei `ggplots` nebeneinander darzustellen. Formuliert nun eine Erwartungshaltung: ist Morans $I$ auf der Ebene Bezirke tiefer oder Höher als auf der Ebene Kantone? \n\n:::{.callout-note}\n## Für Fortgeschrittene \n\nErstellt aus dem erarbeiten Workflow eine *function* um Morans I auf der Basis von einem `sf` Objekt sowie einer Spalte dessen zu berechnen. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmorans_i <- function(sf_object,col) {\n  library(\"sf\")\n  # Zähler 1 ####################################\n  n <- nrow(sf_object)\n  zaehler1 <- n\n  y <- sf_object[[col]] # <- siehe Kommentar unten\n  ###############################################\n  # Nenner 1 ####################################\n  resultat <- double(length = n)\n  for (i in 1:n){\n    resultat[i] <- (y[i]-mean(y))^2\n  }\n  nenner1 <- sum(resultat)\n  ###############################################\n  # Nenner 2 ####################################\n  w <- st_touches(sf_object,sparse = FALSE)\n  resultat_aussen <- integer(length = n)\n  for (i in 1:n){\n    resultat_innen <- integer(length = n)\n    for (j in 1:n){\n      resultat_innen[j] <- w[i, j]\n    }\n    resultat_aussen[i] <- sum(resultat_innen)\n  }\n  nenner2 <- sum(resultat_aussen)\n  ##############################################\n  # Zähler 2 ###################################\n  resultat_aussen <- double(length = n)\n\n  for (i in 1:n){\n    resultat_innen <- double(length = n)\n    for (j in 1:n){\n      resultat_innen[j] <- w[i,j] * (y[i]-mean(y))*(y[j]-mean(y))\n    }\n    resultat_aussen[i] <- sum(resultat_innen)\n  }\n\n  zaehler2 <- sum(resultat_aussen)\n  ##############################################\n  # Auflösung ##################################\n  MI <- zaehler1/nenner1 * zaehler2/nenner2\n\n  return(MI)\n}\n\n# Kommentar\n# Wir können hier nicht das $ Zeichen verwenden, weil \"col\" ein String ist.\n# Mit der doppelten, eckigen klammer stellen wir sicher, dass y erstens ein\n# Vektor ist (schau dir \"y\" an wenn du nur eine Klammer verwendest)\n```\n:::\n\n\n:::\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nzweitwohnung_bezirke <- read_sf(\"datasets/rauman/zweitwohnungsinitiative.gpkg\", \"bezirk\")\nMI_bezirke <- morans_i(zweitwohnung_bezirke, \"ja_in_percent\")\n```\n:::\n\n::: {.cell .column-page layout-ncol=\"2\"}\n::: {.cell-output-display}\n![](Rauman3_Uebung_A_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n\n::: {.cell-output-display}\n![](Rauman3_Uebung_A_files/figure-html/unnamed-chunk-15-2.png){width=672}\n:::\n:::\n\n::: {.cell .column-page}\n::: {.cell-output-display}\n![](Rauman3_Uebung_A_files/figure-html/unnamed-chunk-16-1.png){width=100%}\n:::\n:::\n",
    "supporting": [
      "Rauman3_Uebung_A_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}