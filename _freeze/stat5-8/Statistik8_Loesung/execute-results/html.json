{
  "hash": "228442fcac35f04d8afdfca4bdf2f07d",
  "result": {
    "markdown": "---\ndate: 2023-11-21\nlesson: Stat8\nthema: Clusteranalysen\nindex: 3\nformat:\n  html:\n    code-tools:\n      source: true\n---\n\n\n# Stat8: Lösung\n\n- Download dieses Lösungsscript via \"\\</\\>Code\" (oben rechts)\n- [Lösungstext als Download](Statistik_Loesungstext_8.1.pdf)\n\n## Musterlösung Aufgabe 8.1: Clusteranalysen\n\n### Übungsaufgabe \n\n*(hier so ausführlich formuliert, wie dies auch in der Klausur der Fall sein wird)*\n\n- Ladet den Datensatz crime2.csv. Dieser enthält Raten von 7 Kriminatlitätsformen pro 100000 Einwohner und Jahr für die Bundesstaaten der USA.\n- Führt eine k-means- und eine agglomerative Clusteranalyse eurer Wahl durch. Bitte beachet, dass wegen der sehr ungleichen Varianzen in jedem Fall eine Standardisierung stattfinden muss, damit die Distanzen zwischen den verschiedenen Kriminalitätsraten sinnvoll berechnet werden können.\n- **Überlegt in beiden Fällen, wie viele Cluster sinnvoll sind** (k-means: z. B. visuelle Betrachtung einer PCA, agglomertive Clusteranalyse: z. B. Silhoutte-Plot).\n- Entscheidet euch dann für eine der beiden Clusterungen und vergleicht dann die\nerhaltenen Cluster bezüglich der Kriminalitätsformen und interpretiert die Cluster entsprechend.\n- Bitte erklärt und begründet die einzelnen Schritte, die ihr unternehmt, um zu diesem Ergebnis zu kommen. Dazu erstellt bitte ein Word-Dokument, in das ihr Schritt für Schritt den verwendeten R-Code, die dazu gehörigen Ausgaben von R, eure Interpretation derselben und die sich ergebenden Schlussfolgerungen für das weitere Vorgehen dokumentieren.\n- Formuliert abschliessend einen Methoden- und Ergebnisteil (ggf. incl. adäquaten Abbildungen) zu dieser Untersuchung in der Form einer wissenschaftlichen Arbeit (ausformulierte schriftliche Zusammenfassung, mit je einem Absatz von ca. 60-100 Worten, resp. 3-8 Sätzen für den Methoden- und Ergebnisteil). D. h. alle wichtigen Informationen sollten enthalten sein, unnötige Redundanz dagegen vermieden werden.\n- **Abzugeben sind am Ende (a) Ein lauffähiges R-Skript; (b) begründeter Lösungsweg (Kombination aus R-Code, R Output und dessen Interpretation) und (c) ausformulierter Methoden- und Ergebnisteil (für eine wiss. Arbeit).**\n\n### Lösung\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrime <- read.csv(\"datasets/stat5-8/crime2.csv\", sep = \";\")\n## Error in file(file, \"rt\"): kann Verbindung nicht öffnen\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ncrime\n## Error in eval(expr, envir, enclos): Objekt 'crime' nicht gefunden\n```\n:::\n\n\nIm mitgelieferten R-Skript habe ich die folgenden Analysen zunächst mit untransformierten, dann mit standardisierten Kriminalitätsraten berechnet. Ihr könnt die Ergebnisse vergleichen und seht, dass sie sehr unterschiedlich ausfallen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncrimez <- crime\n## Error in eval(expr, envir, enclos): Objekt 'crime' nicht gefunden\ncrimez[, c(2:8)] <- lapply(crime[, c(2:8)], scale)\n## Error in lapply(crime[, c(2:8)], scale): Objekt 'crime' nicht gefunden\ncrimez\n## Error in eval(expr, envir, enclos): Objekt 'crimez' nicht gefunden\n```\n:::\n\n\n„scale“ führt eine Standardisierung (z-Transformation) durch, so dass alle Variablen anschiessen einen Mittelwert von 0 und eine SD von 1 haben, ausgenommen natürlich die 1. Spalte mit den Kürzeln der Bundesstaaten.\nAnschliessend wird das SSI-Kriterium getestet und zwar für Partitionierungen von 2 bis 6 Gruppen (wie viele Gruppen man maximal haben will, muss man pragmatisch nach der jeweiligen Fragestelltung entscheiden).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"vegan\")\n## Error in library(\"vegan\"): es gibt kein Paket namens 'vegan'\ncrimez.KM.cascade <- cascadeKM(crimez[, c(2:8)],\n  inf.gr = 2, sup.gr = 6, iter = 100, criterion = \"ssi\"\n)\n## Error in cascadeKM(crimez[, c(2:8)], inf.gr = 2, sup.gr = 6, iter = 100, : konnte Funktion \"cascadeKM\" nicht finden\nsummary(crimez.KM.cascade)\n## Error in summary(crimez.KM.cascade): Objekt 'crimez.KM.cascade' nicht gefunden\n\ncrimez.KM.cascade$results\n## Error in eval(expr, envir, enclos): Objekt 'crimez.KM.cascade' nicht gefunden\ncrimez.KM.cascade$partition\n## Error in eval(expr, envir, enclos): Objekt 'crimez.KM.cascade' nicht gefunden\n\n# k-means visualisation\nlibrary(\"cclust\")\n## Error in library(\"cclust\"): es gibt kein Paket namens 'cclust'\nplot(crimez.KM.cascade, sortg = TRUE)\n## Error in plot(crimez.KM.cascade, sortg = TRUE): Objekt 'crimez.KM.cascade' nicht gefunden\n```\n:::\n\n\nNach SSI ist die 4-Gruppenlösung die beste, mit dieser wird also weitergerechnet.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 4 Kategorien sind nach SSI offensichtlich besonders gut\nmodelz <- kmeans(crimez[, c(2:8)], 4)\n## Error in as.matrix(x): Objekt 'crimez' nicht gefunden\nmodelz\n## Error in eval(expr, envir, enclos): Objekt 'modelz' nicht gefunden\n\n# File für ANOVA (Originaldaten der Vorfälle, nicht die ztransformierten)\ncrime.KM4 <- data.frame(crime, modelz[1])\n## Error in data.frame(crime, modelz[1]): Objekt 'crime' nicht gefunden\ncrime.KM4$cluster <- as.factor(crime.KM4$cluster)\n## Error in is.factor(x): Objekt 'crime.KM4' nicht gefunden\ncrime.KM4\n## Error in eval(expr, envir, enclos): Objekt 'crime.KM4' nicht gefunden\nstr(crime.KM4)\n## Error in str(crime.KM4): Objekt 'crime.KM4' nicht gefunden\n```\n:::\n\n\n**Von den agglomerativen Clusterverfahren habe ich mich für Ward’s minimum variance clustering entschieden, da dieses allgemein als besonders geeignet gilt.**\n\nVor der Berechnung von crime.norm und crime.ch muss man die Spalte mit den\nBundesstaatenkürzeln entfern.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Agglomerative Clusteranalyse\ncrime2 <- crime[, -1]\n## Error in eval(expr, envir, enclos): Objekt 'crime' nicht gefunden\ncrime.norm <- decostand(crime2, \"normalize\")\n## Error in decostand(crime2, \"normalize\"): konnte Funktion \"decostand\" nicht finden\ncrime.ch <- vegdist(crime.norm, \"euc\")\n## Error in vegdist(crime.norm, \"euc\"): konnte Funktion \"vegdist\" nicht finden\n# Attach site names to object of class 'dist'\nattr(crime.ch, \"Labels\") <- crime[, 1]\n## Error in eval(expr, envir, enclos): Objekt 'crime' nicht gefunden\n\n# Ward's minimum variance clustering\ncrime.ch.ward <- hclust(crime.ch, method = \"ward.D2\")\n## Error in hclust(crime.ch, method = \"ward.D2\"): Objekt 'crime.ch' nicht gefunden\npar(mfrow = c(1, 1))\nplot(crime.ch.ward, labels = crime[, 1], main = \"Chord - Ward\")\n## Error in plot(crime.ch.ward, labels = crime[, 1], main = \"Chord - Ward\"): Objekt 'crime.ch.ward' nicht gefunden\n\n# Choose and rename the dendrogram (\"hclust\" object)\nhc <- crime.ch.ward\n## Error in eval(expr, envir, enclos): Objekt 'crime.ch.ward' nicht gefunden\n# hc <- spe.ch.beta2\n# hc <- spe.ch.complete\ndev.new(title = \"Optimal number of clusters\", width = 12, height = 8, noRStudioGD = TRUE)\ndev.off()\n## png \n##   2\npar(mfrow = c(1, 2))\n\n# Average silhouette widths (Rousseeuw quality index)\nlibrary(\"cluster\")\nSi <- numeric(nrow(crime))\n## Error in nrow(crime): Objekt 'crime' nicht gefunden\nfor (k in 2:(nrow(crime) - 1))\n{\n  sil <- silhouette(cutree(hc, k = k), crime.ch)\n  Si[k] <- summary(sil)$avg.width\n}\n## Error in nrow(crime): Objekt 'crime' nicht gefunden\nk.best <- which.max(Si)\n## Error in which.max(Si): Objekt 'Si' nicht gefunden\nplot(1:nrow(crime), Si,\n  type = \"h\",\n  main = \"Silhouette-optimal number of clusters\",\n  xlab = \"k (number of clusters)\", ylab = \"Average silhouette width\"\n)\n## Error in nrow(crime): Objekt 'crime' nicht gefunden\n\naxis(1, k.best, paste(\"optimum\", k.best, sep = \"\\n\"),\n  col = \"red\",\n  font = 2, col.axis = \"red\"\n)\n## Error in axis(1, k.best, paste(\"optimum\", k.best, sep = \"\\n\"), col = \"red\", : Objekt 'k.best' nicht gefunden\npoints(k.best, max(Si), pch = 16, col = \"red\", cex = 1.5)\n## Error in points(k.best, max(Si), pch = 16, col = \"red\", cex = 1.5): Objekt 'k.best' nicht gefunden\n```\n:::\n\n\nDemnach wären beim Ward’s-Clustering nur zwei Gruppen die optimale Lösung.\n\n**Für die Vergleiche der Bundesstaatengruppen habe ich mich im Folgenden für die k-means Clusterung mit 4 Gruppen entschieden.**\n\nDamit die Boxplots und die ANOVA direkt interpretierbar sind, werden für diese, anders als für die Clusterung, die untransformierten Incidenz-Werte verwendet (also crime statt crimez). Die Spalte mit der Clusterzugehörigkeit im Fall von k-means mit 4 Clustern hängt man als Spalte an (Achtung: muss als Faktor definiert werden!).\n\nAnschliessend kann man die 7 ANOVAs rechnen, die Posthoc-Vergleiche durchführen und die zugehörigen Boxplots mit Buchstaben für die homogenen Gruppen erzeugen. Sinnvollerweise gruppiert man die Abbildungen gleich, z. B. je 2 x 2. Das Skript ist hier simple für jede Verbrechensart wiederholt. Erfahrenere R-Nutzer können das Ganze hier natürlich durch eine Schleife abkürzen.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"multcomp\")\n## Error in library(\"multcomp\"): es gibt kein Paket namens 'multcomp'\npar(mfrow = c(3, 3))\n\nANOVA.Murder <- aov(Murder ~ cluster, data = crime.KM4)\n## Error in terms.formula(formula, \"Error\", data = data): Objekt 'crime.KM4' nicht gefunden\nsummary(ANOVA.Murder)\n## Error in summary(ANOVA.Murder): Objekt 'ANOVA.Murder' nicht gefunden\nletters <- cld(glht(ANOVA.Murder, linfct = mcp(cluster = \"Tukey\")))\n## Error in cld(glht(ANOVA.Murder, linfct = mcp(cluster = \"Tukey\"))): konnte Funktion \"cld\" nicht finden\nboxplot(Murder ~ cluster, xlab = \"Cluster\", ylab = \"Murder\", data = crime.KM4)\n## Error in eval(m$data, parent.frame()): Objekt 'crime.KM4' nicht gefunden\nmtext(letters$mcletters$Letters, at = 1:6)\n## Error in letters$mcletters: $ operator is invalid for atomic vectors\n\nANOVA.Rape <- aov(Rape ~ cluster, data = crime.KM4)\n## Error in terms.formula(formula, \"Error\", data = data): Objekt 'crime.KM4' nicht gefunden\nsummary(ANOVA.Rape)\n## Error in summary(ANOVA.Rape): Objekt 'ANOVA.Rape' nicht gefunden\nletters <- cld(glht(ANOVA.Rape, linfct = mcp(cluster = \"Tukey\")))\n## Error in cld(glht(ANOVA.Rape, linfct = mcp(cluster = \"Tukey\"))): konnte Funktion \"cld\" nicht finden\nboxplot(Rape ~ cluster, xlab = \"Cluster\", ylab = \"Rape\", data = crime.KM4)\n## Error in eval(m$data, parent.frame()): Objekt 'crime.KM4' nicht gefunden\nmtext(letters$mcletters$Letters, at = 1:6)\n## Error in letters$mcletters: $ operator is invalid for atomic vectors\n\nANOVA.Robbery <- aov(Robbery ~ cluster, data = crime.KM4)\n## Error in terms.formula(formula, \"Error\", data = data): Objekt 'crime.KM4' nicht gefunden\nsummary(ANOVA.Robbery)\n## Error in summary(ANOVA.Robbery): Objekt 'ANOVA.Robbery' nicht gefunden\nletters <- cld(glht(ANOVA.Robbery, linfct = mcp(cluster = \"Tukey\")))\n## Error in cld(glht(ANOVA.Robbery, linfct = mcp(cluster = \"Tukey\"))): konnte Funktion \"cld\" nicht finden\nboxplot(Robbery ~ cluster, xlab = \"Cluster\", ylab = \"Robbery\", data = crime.KM4)\n## Error in eval(m$data, parent.frame()): Objekt 'crime.KM4' nicht gefunden\nmtext(letters$mcletters$Letters, at = 1:6)\n## Error in letters$mcletters: $ operator is invalid for atomic vectors\n\nANOVA.Assault <- aov(Assault ~ cluster, data = crime.KM4)\n## Error in terms.formula(formula, \"Error\", data = data): Objekt 'crime.KM4' nicht gefunden\nsummary(ANOVA.Assault)\n## Error in summary(ANOVA.Assault): Objekt 'ANOVA.Assault' nicht gefunden\nletters <- cld(glht(ANOVA.Assault, linfct = mcp(cluster = \"Tukey\")))\n## Error in cld(glht(ANOVA.Assault, linfct = mcp(cluster = \"Tukey\"))): konnte Funktion \"cld\" nicht finden\nboxplot(Assault ~ cluster, xlab = \"Cluster\", ylab = \"Assault\", data = crime.KM4)\n## Error in eval(m$data, parent.frame()): Objekt 'crime.KM4' nicht gefunden\nmtext(letters$mcletters$Letters, at = 1:6)\n## Error in letters$mcletters: $ operator is invalid for atomic vectors\n\nANOVA.Burglary <- aov(Burglary ~ cluster, data = crime.KM4)\n## Error in terms.formula(formula, \"Error\", data = data): Objekt 'crime.KM4' nicht gefunden\nsummary(ANOVA.Burglary)\n## Error in summary(ANOVA.Burglary): Objekt 'ANOVA.Burglary' nicht gefunden\nletters <- cld(glht(ANOVA.Burglary, linfct = mcp(cluster = \"Tukey\")))\n## Error in cld(glht(ANOVA.Burglary, linfct = mcp(cluster = \"Tukey\"))): konnte Funktion \"cld\" nicht finden\nboxplot(Burglary ~ cluster, data = crime.KM4, xlab = \"Cluster\", ylab = \"Burglary\")\n## Error in eval(m$data, parent.frame()): Objekt 'crime.KM4' nicht gefunden\nmtext(letters$mcletters$Letters, at = 1:6)\n## Error in letters$mcletters: $ operator is invalid for atomic vectors\n\nANOVA.Theft <- aov(Theft ~ cluster, data = crime.KM4)\n## Error in terms.formula(formula, \"Error\", data = data): Objekt 'crime.KM4' nicht gefunden\nsummary(ANOVA.Theft)\n## Error in summary(ANOVA.Theft): Objekt 'ANOVA.Theft' nicht gefunden\nletters <- cld(glht(ANOVA.Theft, linfct = mcp(cluster = \"Tukey\")))\n## Error in cld(glht(ANOVA.Theft, linfct = mcp(cluster = \"Tukey\"))): konnte Funktion \"cld\" nicht finden\nboxplot(Theft ~ cluster, xlab = \"Cluster\", ylab = \"Theft\", data = crime.KM4)\n## Error in eval(m$data, parent.frame()): Objekt 'crime.KM4' nicht gefunden\nmtext(letters$mcletters$Letters, at = 1:6)\n## Error in letters$mcletters: $ operator is invalid for atomic vectors\n\nANOVA.Vehicle <- aov(Vehicle ~ cluster, data = crime.KM4)\n## Error in terms.formula(formula, \"Error\", data = data): Objekt 'crime.KM4' nicht gefunden\nsummary(ANOVA.Vehicle)\n## Error in summary(ANOVA.Vehicle): Objekt 'ANOVA.Vehicle' nicht gefunden\nletters <- cld(glht(ANOVA.Vehicle, linfct = mcp(cluster = \"Tukey\")))\n## Error in cld(glht(ANOVA.Vehicle, linfct = mcp(cluster = \"Tukey\"))): konnte Funktion \"cld\" nicht finden\nboxplot(Vehicle ~ cluster, data = crime.KM4, xlab = \"Cluster\", ylab = \"Vehicle\")\n## Error in eval(m$data, parent.frame()): Objekt 'crime.KM4' nicht gefunden\nmtext(letters$mcletters$Letters, at = 1:6)\n## Error in letters$mcletters: $ operator is invalid for atomic vectors\n```\n:::\n\n\nDie Boxplots erlauben jetzt auch eine Beurteilung der Modelldiagnostik: sind die Residuen hinreichen normalverteilt (symmetrisch) und sind die Varianzen zwischen den Kategorien einigermassen ähnlich. Mit der Symmetrie/Normalverteilung sieht es OK aus. Die Varianzhomogenität ist nicht optimal – meist deutlich grössere Varianz bei höheren Mittelwerten. Eine log-Transformation hätte das verbessert und könnte hier gut begründet werden. Da die p-Werte sehr niedrig waren und die Varianzheterogenität noch nicht extrem war, habe ich aber von einer Transformation abgesehen, da jede Transformation die Interpretation der Ergebnisse erschwert. Jetzt muss man nur noch herausfinden, welche Bundesstaaten überhaupt zu welchem der vier\nCluster gehören, sonst ist das ganze schöne Ergebnis nutzlos. Z. B. kann man in R auf den Dataframe clicken und ihn nach cluster sortieren.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}